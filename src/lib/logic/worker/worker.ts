import * as factorio from '$lib/factorio-blueprint-utils/src';
import type { Config, Extent, Items, WorkerResponse } from '$lib/types';
import { calculateBlueprints } from '../generator/generator';
import { encode } from '../serialization';

onmessage = async (event) => {
	const start = performance.now();
	processBlueprintRequest(event.data.file, event.data.config, event.data.extent);
	const end = performance.now();
	console.info(`Worker took ${end - start}ms`);
};

const canvas = new OffscreenCanvas(1, 1);
const context = canvas.getContext('2d', { willReadFrequently: true, alpha: true });

const processBlueprintRequest = async (file: File, config: Config, extent: Extent) => {
	postMessage({ type: 'status', data: 'Reading Image...' });
	const bitmap = await createImageBitmap(file);
	const imageData = getImageData(bitmap);
	if (imageData === undefined) {
		postMessage({ type: 'error', data: 'Failed to read image data' });
		return;
	}

	postMessage({ type: 'status', data: 'Converting to blueprint...' });
	const blueprints = calculateBlueprints(imageData.data, config, extent, (data) =>
		postMessage({ type: 'progress', data })
	);

	postMessage({ type: 'status', data: 'Calculating statistics...' });
	const statistics = computeBlueprintStatistics(blueprints);
	postMessage({ type: 'stats', data: statistics });

	postMessage({ type: 'status', data: 'Generating Import String...' });
	const exportData = getExport(blueprints, config);

	postMessage({ type: 'status', data: 'Encoding...' });
	const exportString = encode(exportData);

	postMessage({ type: 'status', data: 'Creating File...' });
	const exportFile = new File([exportString], 'export.txt');

	postMessage({ type: 'status', data: 'Sending...' });
	const exportResponse: WorkerResponse = {
		type: 'file',
		data: exportFile
	};
	postMessage({ type: 'status', data: 'Sent' });

	postMessage(exportResponse);
};

const getImageData = (image: ImageBitmap): ImageData | undefined => {
	canvas.width = image.width;
	canvas.height = image.height;
	context?.drawImage(image, 0, 0, image.width, image.height);
	return context?.getImageData(0, 0, image.width, image.height);
};

const computeBlueprintStatistics = (blueprints: factorio.WrappedBlueprint[]) => {
	return blueprints.reduce(
		(stats, blueprint) => {
			blueprint.blueprint.entities.forEach((entity) => {
				if (entity.name in stats) {
					stats[entity.name as Items]++;
				} else {
					stats[entity.name as Items] = 1;
				}
			});
			blueprint.blueprint.tiles.forEach((tile) => {
				if (tile.name in stats) {
					stats[tile.name as Items]++;
				} else {
					stats[tile.name as Items] = 1;
				}
			});

			return stats;
		},
		{} as Record<Items, number>
	);
};

const getExport = (
	blueprints: factorio.WrappedBlueprint[],
	config: Config
): factorio.Serializable | null => {
	if (blueprints.length === 0) {
		return null;
	}

	if (config.isBook) {
		return {
			blueprint_book: {
				blueprints: blueprints,
				label: config.name,
				item: 'blueprint-book',
				description: 'This is description',
				active_index: 0,
				version: 1
			}
		} as factorio.WrappedBlueprintBook;
	}

	return {
		blueprint: {
			name: config.name,
			...blueprints[0].blueprint,
			description: 'Blueprint generated by Factorio Blueprint Generator',
			label: config.name
		}
	} as factorio.WrappedBlueprint;
};
